var documenterSearchIndex = {"docs":
[{"location":"functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Modules = [KidneyExchange]\nOrder   = [:function]","category":"page"},{"location":"functions/#KidneyExchange.Bellman_Ford_cycle_search-Tuple{Graphs.SimpleGraphs.SimpleDiGraph, Vector{Float64}, Int64, Int64, BitVector, Vector{Vector{Int64}}, Vector{Float64}, Float64}","page":"Functions","title":"KidneyExchange.Bellman_Ford_cycle_search","text":"Bellman_Ford_cycle_search(\n    graph,\n    vertex_cost,\n    source,\n    K,\n    is_covered,\n    pred,\n    d,\n    constant_cost\n)\n\n\nBellman-Ford style search for one positive cost cycle\n\nArguments\n\ngraph::SimpleDiGraph : The directed graph with cost on each arc\narc_cost::Matrix{Float64}:\nsource::Int : The local vertex index from which starts the search\nK::Int : The maximal length of cycles\npred[k][v] contains u if u is a predecessor of v in a path of length k from source\n\nReturn values\n\ncycle::Vector{Int}: the positive cycle found, [] if none\n\n\n\n\n\n","category":"method"},{"location":"functions/#KidneyExchange.MIP_chain_search","page":"Functions","title":"KidneyExchange.MIP_chain_search","text":"MIP_chain_search(mip, graph, source, is_vertex, arc_cost)\nMIP_chain_search(\n    mip,\n    graph,\n    source,\n    is_vertex,\n    arc_cost,\n    verbose\n)\n\n\nIP model with subtour elimination constraints. The constraints are the  generalized cutset inequalities (GCS) and they are added dynamically in a row generation algorithm. Refer for instance to the following reference for a presentation of the GCS: (Taccari, 2016).\n\nArguments\n\nmip::Model: The JuMP model initialized with the flow conservation constraints and the bound on the length of the chain\ngraph::SimpleDiGraph : The directed graph with cost on each arc\nsource::Int: Index of the source vertex\nis_vertex::BitVector: For each vertex, indicates if it is in the considered subgraph\narc_cost::Vector{Float64}: Matrix of reduced costs of every arc\n\nReturn values\n\nis_positivie_chain::Bool: True if a positive chain was found\nchain::Vector{Int}: Positive chain that was found\n\n\n\n\n\n","category":"function"},{"location":"functions/#KidneyExchange.SaidmanPoolGenerator-Tuple{Int64}","page":"Functions","title":"KidneyExchange.SaidmanPoolGenerator","text":"SaidmanPoolGenerator(id)\n\n\nNumbers taken from Saidman et al. (2006)\n\n\n\n\n\n","category":"method"},{"location":"functions/#KidneyExchange.SparseUNOSSaidmanPoolGenerator-Tuple{Int64}","page":"Functions","title":"KidneyExchange.SparseUNOSSaidmanPoolGenerator","text":"SparseUNOSSaidmanPoolGenerator(id)\n\n\nA tweak to the published Saidman generator; distributions VERY ROUGHLY mimic the UNOS pool as of April 15, 2013.  Data taken from the KPD Work Group Data Analysis - CMR - June 2013 report Dickerson et al. (2016).\n\n\n\n\n\n","category":"method"},{"location":"functions/#KidneyExchange.activate_branching_constraints-Tuple{JuMP.Model, KidneyExchange.TreeNode, BP_params}","page":"Functions","title":"KidneyExchange.activate_branching_constraints","text":"activate_branching_constraints(master, tree_node, bp_params)\n\n\nActivate the all the branching constraints corresponding to a given node of the branch-and-price enumeration tree.\n\n\n\n\n\n","category":"method"},{"location":"functions/#KidneyExchange.add_column_to_master-Tuple{KidneyExchange.Column, JuMP.Model, KidneyExchange.TreeNode}","page":"Functions","title":"KidneyExchange.add_column_to_master","text":"add_column_to_master(column, mastermodel, tree_node)\n\n\nArguments\n\ncolumn::Column: Column to add to the master model\nmastermodel::Model: JuMP model for current master problem\ntreenode::TreeNode: Information on current tree node\n\nReturn values: None\n\n\n\n\n\n","category":"method"},{"location":"functions/#KidneyExchange.bfs","page":"Functions","title":"KidneyExchange.bfs","text":"bfs(g, source, K)\nbfs(g, source, K, vertex_in_subgraph)\nbfs(g, source, K, vertex_in_subgraph, d_from_vstar)\n\n\nBreadth-first search to calculate the shortest path in terms of number of arcs from source to other vertices of graph g. The search stops when it is at level K even if there is vertex to be visited. Because we are trying to find cycles of at most K length, vertices of level >=K are never be considered in cycles.\n\nInput parameters\n\ng::AbstractGraph{T} : The graph\nsource::Int : The source vertex\nK::Int: The maximum number of arcs\nvertex_in_subgraph::Array{Bool}: Table indicating for each vertex if it is in the subgraph under consideration\n\nOutput parameters\n\ndists::Vector{Float64}: shortest distance from source to vertices\n\n\n\n\n\n","category":"function"},{"location":"functions/#KidneyExchange.bfs_reverse","page":"Functions","title":"KidneyExchange.bfs_reverse","text":"bfs_reverse(g, source, K)\nbfs_reverse(g, source, K, vertex_in_subgraph)\nbfs_reverse(g, source, K, vertex_in_subgraph, d_to_vstar)\n\n\nBreadth-first search in the graph where arcs are reversed\n\nInput parameters\n\ng::AbstractGraph{T} : The graph\nsource::Int : The source vertex\nK::Int: The maximum number of arcs\nvertex_in_subgraph::Array{Bool}: Table indicating for each vertex if it is in the subgraph under consideration\n\nOutput parameters\n\ndists::Vector{Float64}: shortest distance from source to vertices\n\n\n\n\n\n","category":"function"},{"location":"functions/#KidneyExchange.branch_and_price-Tuple{KidneyExchange.Instance, KidneyExchange.Graph_copies, BP_params, TimerOutput, Real}","page":"Functions","title":"KidneyExchange.branch_and_price","text":"branch_and_price(\n    instance,\n    subgraphs,\n    bp_params,\n    timer,\n    time_limit\n)\n\n\nCore function of the KEP solution with branch-and-price. It requires a parsed instance and the description of the graph copies. The column generation model is that of Riazcos-Alvarez et al (2020), but the many improvements have been added, in particular in the solution of the subproblem.\n\nArguments\n\ninstance::Instance: The parsed instance that is to be solved, it contains the KEP graph and the bounds on the length of covering cycles and chains\nsubgraphs::Graph_copies: Description of the graph copies of the extended edge formulation\nbp_params::BP_params: solution parameters of the branch-and-price\ntimer::TimerOutput: a timer that will provide detail of where the computational time was spent during the branch-and-price\ntime_limit::Float64: time limit of the algorithm, including parsing and prepreprocessing times\n\n#Output parametes\n\nbp_status::BP_status:  Structure containing every relevant information on the execution of the algorithm (including the optimal solution)\n\n\n\n\n\n","category":"method"},{"location":"functions/#KidneyExchange.branch_on_arc","page":"Functions","title":"KidneyExchange.branch_on_arc","text":"branch_on_arc(\n    arc_to_branch,\n    master,\n    is_cg_branching,\n    tree,\n    current_node,\n    column_pool,\n    node_count\n)\nbranch_on_arc(\n    arc_to_branch,\n    master,\n    is_cg_branching,\n    tree,\n    current_node,\n    column_pool,\n    node_count,\n    verbose\n)\n\n\nUpdate the branch-and-bound tree with two new nodes by branching on the given arc with the specified branching (only on master problem or both in master and in subproblem)\n\nInput parameters\n\narc_to_branch::Pair{Int,Int} : The arc to be branched\nmaster::Model: Master model where the branching constraints are added\nis_cg_branching::Bool: True if the branching impacts the subproblem of the coluln generation, false if it impacts only the master problem\ntree::Vector{TreeNode}: Branch-and-bound tree\ncurrent_node::TreeNode: Branch-and-bound node currently treated\ncolumn_pool::Vector{Column}: Pool of all columns in current master problem\nnode_count::Int: Number of BP nodes enumerated until now\n\n\n\n\n\n","category":"function"},{"location":"functions/#KidneyExchange.branch_on_vertex","page":"Functions","title":"KidneyExchange.branch_on_vertex","text":"branch_on_vertex(\n    vertex_to_branch,\n    master,\n    tree,\n    current_node,\n    column_pool,\n    node_count\n)\nbranch_on_vertex(\n    vertex_to_branch,\n    master,\n    tree,\n    current_node,\n    column_pool,\n    node_count,\n    verbose\n)\n\n\nUpdate the branch-and-bound tree with two new nodes by branching on the given vertex.\n\nInput parameters\n\nvertex_to_branch::Int : The arc to be branched\nmaster::Model: Master model where the branching constraints are added\ntree::Vector{TreeNode}: Branch-and-bound tree\ncurrent_node::TreeNode: Branch-and-bound node currently treated\ncolumn_pool::Vector{Column}: Pool of all columns in current master problem\n\n** node_count::Int: Number of BP nodes enumerated until now\n\n\n\n\n\n","category":"function"},{"location":"functions/#KidneyExchange.build_hpief_mip","page":"Functions","title":"KidneyExchange.build_hpief_mip","text":"build_hpief_mip(instance, subgraphs, params)\nbuild_hpief_mip(instance, subgraphs, params, maxtime)\n\n\nA compact MIP formulation originally proposed by (Dickerson et al., 2016). The hybrid position indexed edge formulation (HPIEF) handles cycles and chains in the same formulation.\n\n\n\n\n\n","category":"function"},{"location":"functions/#KidneyExchange.build_reduced_extended_edge_mip","page":"Functions","title":"KidneyExchange.build_reduced_extended_edge_mip","text":"build_reduced_extended_edge_mip(instance, subgraphs, params)\nbuild_reduced_extended_edge_mip(\n    instance,\n    subgraphs,\n    params,\n    maxtime\n)\n\n\nA compact MIP formulation originally proposed by (Constantino et al., 2013) for the cycles-only variant of the problem. Here it is adapted to the graph copies based on FVS and chains are considered with position-indexed variables.\n\n\n\n\n\n","category":"function"},{"location":"functions/#KidneyExchange.canGetFrom-Tuple{KidneyExchange.Blood_type, KidneyExchange.Blood_type}","page":"Functions","title":"KidneyExchange.canGetFrom","text":"canGetFrom(patientBT, donorBT)\n\n\nCan a person with blood type  patientBT receive a kidney of donorBT?\n\n\n\n\n\n","category":"method"},{"location":"functions/#KidneyExchange.canGiveTo-Tuple{KidneyExchange.Blood_type, KidneyExchange.Blood_type}","page":"Functions","title":"KidneyExchange.canGiveTo","text":"canGiveTo(donorBT, patientBT)\n\n\nCan a person with blood type  donorBT give a kidney to a patient with blood type patientBT?\n\n\n\n\n\n","category":"method"},{"location":"functions/#KidneyExchange.check_used_vertices-Tuple{Vector{Int64}, Vector{Vector{Int64}}}","page":"Functions","title":"KidneyExchange.check_used_vertices","text":"check_used_vertices(cycle, cycles)\n\n\nGives a set of indices of cycle in cycles who have common vertices with cycle\n\nArguments\n\ncycle::Array{Int,1}: The vertices of cycle\ncycles::Array{Array{Int,1},1}: The set of cycles\n\n#Output parametes\n\nredundant_cycle_indices::Array{Int,1}: the set of indices of cycle in cycles who have common vertices with cycle\n\n\n\n\n\n","category":"method"},{"location":"functions/#KidneyExchange.compute_arc_flow-Tuple{Vector{Float64}, Vector{KidneyExchange.Column}}","page":"Functions","title":"KidneyExchange.compute_arc_flow","text":"compute_arc_flow(mastersol, node_columns)\n\n\nCalculates the relaxed value of the decision variable x(i,j) of arc (i->j) in A. x(i,j) whose value >0 is stored in x::Dict{Pair{Int,Int}, Float64}\n\nArguments\n\nmastersol::Vector{Float64}: solution value of the master problem, ie: y[c] for c in cycles\nnode_columns::Vector{Column}: The corresponding cycles of current node\n\nReturn values\n\nx:: Dict{Pair{Int,Int}, Float64}: value of x_(i,j) of arc (i->j)\n\n\n\n\n\n","category":"method"},{"location":"functions/#KidneyExchange.create_chain_mip","page":"Functions","title":"KidneyExchange.create_chain_mip","text":"create_chain_mip(graph, L, optimizer, time_limit)\ncreate_chain_mip(\n    graph,\n    L,\n    optimizer,\n    time_limit,\n    nb_threads\n)\n\n\nInitialize the MIP model with cycle constraint generation for the optimal search of positive cost chains. Only one model is created for every copy to save a great amount of initialization time and memory. The model will then need to be modified for each graph copy to keep only the vertices of the graph and select the right source vertex\n\nArguments\n\ngraph::SimpleDiGraph : The directed graph with cost on each arc\nL::Int: The maximal length of chains\noptimizer::String: Name of the MIP sover\ntime_limit::Real: Time limit of the solver\ngurobi_env: Gurobi environment if Gurobi is used (avoids many messages from the solver)\n\nReturn values\n\nmip::Model: Initial JuMP model for the search of a positive chain\n\n\n\n\n\n","category":"function"},{"location":"functions/#KidneyExchange.create_model","page":"Functions","title":"KidneyExchange.create_model","text":"create_model(time_limit, optimizer)\ncreate_model(time_limit, optimizer, is_integer)\ncreate_model(time_limit, optimizer, is_integer, verbose)\ncreate_model(\n    time_limit,\n    optimizer,\n    is_integer,\n    verbose,\n    nb_threads\n)\n\n\n\n\n\n\n","category":"function"},{"location":"functions/#KidneyExchange.deactivate_branching_constraints-Tuple{JuMP.Model, KidneyExchange.TreeNode, BP_params}","page":"Functions","title":"KidneyExchange.deactivate_branching_constraints","text":"deactivate_branching_constraints(\n    master,\n    tree_node,\n    bp_params\n)\n\n\nDeactivate the all the branching constraints corresponding to a given node of the branch-and-price enumeration tree.\n\n\n\n\n\n","category":"method"},{"location":"functions/#KidneyExchange.drawDonorBlood_type-Tuple{KidneyExchange.PoolGenerator}","page":"Functions","title":"KidneyExchange.drawDonorBlood_type","text":"drawDonorBlood_type(pool_gen)\n\n\nDraws a random donor's blood type from the US distribution\nreturn Blood_type.{O,A,B,AB}\n\n\n\n\n\n","category":"method"},{"location":"functions/#KidneyExchange.drawPatientBlood_type-Tuple{KidneyExchange.PoolGenerator}","page":"Functions","title":"KidneyExchange.drawPatientBlood_type","text":"drawPatientBlood_type(pool_gen)\n\n\nDraws a random patient's blood type from the US distribution\nreturn Blood_type.{O,A,B,AB}\n\n\n\n\n\n","category":"method"},{"location":"functions/#KidneyExchange.generateAltruist-Tuple{KidneyExchange.PoolGenerator}","page":"Functions","title":"KidneyExchange.generateAltruist","text":"generateAltruist(pool_gen)\n\n\nRandom rolls an altruistic donor (donor with no attached patient)\n\nID unique identifier for the vertex\nreturn altruistic donor vertex KPDVertexAltruist\n\n\n\n\n\n","category":"method"},{"location":"functions/#KidneyExchange.generatePair-Tuple{KidneyExchange.PoolGenerator}","page":"Functions","title":"KidneyExchange.generatePair","text":"generatePair(pool_gen)\n\n\nRandomly rolls a patient-donor pair (possibly compatible or incompatible)\n\nID unique identifier for the vertex\nreturn a patient-donor pair KPDVertexPair\n\n\n\n\n\n","category":"method"},{"location":"functions/#KidneyExchange.generatePraIncompatibility-Tuple{KidneyExchange.PoolGenerator, Bool}","page":"Functions","title":"KidneyExchange.generatePraIncompatibility","text":"generatePraIncompatibility(pool_gen, isWifePatient)\n\n\nRandomly generates CPRA (Calculated Panel Reactive Antibody) for a patient-donor pair, using the Saidman method.  If the patient is the donor's wife, then CPRA is increased.\n\nisWifePatient is the patent the wife of the donor?\nreturn scaled CPRA double value between 0 and 1.0\n\n\n\n\n\n","category":"method"},{"location":"functions/#KidneyExchange.generate_abraham_benchmark-Tuple{}","page":"Functions","title":"KidneyExchange.generate_abraham_benchmark","text":"generate_abraham_benchmark()\n\n\nGenerate a benchmark using the same method as that used in (Abraham et al., 2007)\n\n\n\n\n\n","category":"method"},{"location":"functions/#KidneyExchange.generate_complete_benchmark-Tuple{}","page":"Functions","title":"KidneyExchange.generate_complete_benchmark","text":"generate_complete_benchmark()\n\n\nGenerate all the instances that are used in addition to the PrefLib to assess the solution methods of this package in the article describing the package (Jérémy Omer, Ayse N Arslan, Fulin Yan. KidneyExchange.jl: A Julia package for solving the kidney exchange problem with branch-and-price. 2022. ⟨hal-03830810⟩).\n\nThe instances are stored in the subdirectories heterogeneous, sparse and saidman of the data directory. Beware that if using the package with Pkg.add(), the data directory is in the directory where the package is stored.\n\n\n\n\n\n","category":"method"},{"location":"functions/#KidneyExchange.generate_heterogeneous_instance-Tuple{Int64, Int64, Int64}","page":"Functions","title":"KidneyExchange.generate_heterogeneous_instance","text":"generate_heterogeneous_instance(\n    nb_pairs,\n    nb_altruists,\n    index\n)\n\n\nGenerate a KEP dataset and write in two text files with extensions .dat and .wmd; the graph generator is based on the following article: Kidney Exchange in Dynamic Sparse Heterogeneous Pools: (Ashlagi et al., 2013).\n\nArguments\n\nnb_pairs::Int: number of pairs of incompatible donor and patient\nnb_altruists::Int: number of altruist donors\nindex::Int: index of the dataset, which will appear in the filename\n\n\n\n\n\n","category":"method"},{"location":"functions/#KidneyExchange.generate_heterogeneous_kep_graph","page":"Functions","title":"KidneyExchange.generate_heterogeneous_kep_graph","text":"generate_heterogeneous_kep_graph(nb_pairs, nb_altruists)\ngenerate_heterogeneous_kep_graph(\n    nb_pairs,\n    nb_altruists,\n    pct_easy_to_match\n)\n\n\nCompatibility graph generator based on the following paper: Kidney Exchange in Dynamic Sparse Heterogeneous Pools. Itai Ashlagi, Patrick Jaillet, Vahideh H. Manshadi. EC-2013.  (Extended abstract.)  @author John P. Dickerson\n\n\n\n\n\n","category":"function"},{"location":"functions/#KidneyExchange.generate_kep_graph-Tuple{KidneyExchange.PoolGenerator, Int64, Int64}","page":"Functions","title":"KidneyExchange.generate_kep_graph","text":"generate_kep_graph(pool_gen, nb_pairs, nb_altruists)\n\n\n\n\n\n\n","category":"method"},{"location":"functions/#KidneyExchange.generate_saidman_instance-Tuple{Int64, Int64, Int64}","page":"Functions","title":"KidneyExchange.generate_saidman_instance","text":"generate_saidman_instance(nb_pairs, nb_altruists, index)\n\n\nGenerate a KEP dataset and write in two text files with extensions .dat and .wmd. This generator is usually refererred to as the \"Saidman Generator\".\n\nArguments\n\nnb_pairs::Int: number of pairs of incompatible donor and patient\nnb_altruists::Int: number of altruist donors\nindex::Int: index of the dataset, which will appear in the filename\n\nReference\n\n(Saidman et al., 2014)\n\n\n\n\n\n","category":"method"},{"location":"functions/#KidneyExchange.generate_saidman_kep_graph-Tuple{Int64, Int64}","page":"Functions","title":"KidneyExchange.generate_saidman_kep_graph","text":"generate_saidman_kep_graph(nb_pairs, nb_altruists)\n\n\n\n\n\n\n","category":"method"},{"location":"functions/#KidneyExchange.generate_sparse_unos_instance-Tuple{Int64, Int64, Int64}","page":"Functions","title":"KidneyExchange.generate_sparse_unos_instance","text":"generate_sparse_unos_instance(nb_pairs, nb_altruists, index)\n\n\nGenerate a KEP dataset and write in two text files with extensions .dat and .wmd. This generator is obtained by applying the Saidman generator with small modifications in the probabilities of compatibility to roughtly mimic the UNOS pool as of April 15, 2013.  The corresponding data was taken from the KPD Work Group Data Analysis - CMR - June 2013 report. Seel also (Dickerson et al., 2012) for the motivation and description of this generator.\n\nArguments\n\nnb_pairs::Int: number of pairs of incompatible donor and patient\nnb_altruists::Int: number of altruist donors\nindex::Int: index of the dataset, which will appear in the filename\n\n\n\n\n\n\n\n","category":"method"},{"location":"functions/#KidneyExchange.generate_sparse_unos_kep_graph-Tuple{Int64, Int64}","page":"Functions","title":"KidneyExchange.generate_sparse_unos_kep_graph","text":"generate_sparse_unos_kep_graph(nb_pairs, nb_altruists)\n\n\n\n\n\n\n","category":"method"},{"location":"functions/#KidneyExchange.get_branching_arc-Tuple{Dict{Pair{Int64, Int64}, Float64}, Dict{Pair{Int64, Int64}, Float64}}","page":"Functions","title":"KidneyExchange.get_branching_arc","text":"get_branching_arc(column_flow, pief_flow)\n\n\nFind a fractional arc to branch. The fractional arc closest to 0.5 will be selected to branch, if there is no fractional arc in the solution\n\nInput parameters\n\ncolumn_flow::Dict{Pair{Int,Int}, Float64} : The dictionary containing the nonzero flow on each arc due to the selection of columns\npief_flow::Dict{Pair{Int,Int}, Float64} : The dictionary containing the flow on each arc from the pief model for chain search (if applicable)\n\nOutput parameters\n\narc_to_branch::Pair{Int,Int} : The arc to be branched\nis_cg_branching::Bool: True if the branching impacts the subproblem of the coluln generation, false if it impacts only the master problem\n\n\n\n\n\n","category":"method"},{"location":"functions/#KidneyExchange.get_branching_vertex-Tuple{Graphs.SimpleGraphs.SimpleDiGraph, Dict{Pair{Int64, Int64}, Float64}, Dict{Pair{Int64, Int64}, Float64}}","page":"Functions","title":"KidneyExchange.get_branching_vertex","text":"get_branching_vertex(graph, column_flow, pief_flow)\n\n\nFind a fractional vertex cover to branch. The fractional vertex closest to 0.5 will be selected to branch\n\nInput parameters\n\ncolumn_flow::Dict{Pair{Int,Int}, Float64} : The dictionary containing the nonzero flow on each arc due to the selection of columns\npief_flow::Dict{Pair{Int,Int}, Float64} : The dictionary containing the flow on each arc from the pief model for chain search (if applicable)\n\nOutput parameters\n\nvertex_to_branch::Int : The vertex to be branched on, nothing if none was found\n\n\n\n\n\n","category":"method"},{"location":"functions/#KidneyExchange.get_feasible_solution-Tuple{Vector{Float64}, Vector{KidneyExchange.Column}}","page":"Functions","title":"KidneyExchange.get_feasible_solution","text":"get_feasible_solution(fractional_solution, node_columns)\n\n\nExtract a integer feasible solution from the fractional solution by conserving a set of vertex-disjoint cycles or chains\n\nArguments\n\nfractional_solution::Array{Array{Float64,1},1}: The set of value of variables indicating whether or not cycles and chains are selected\nnode_columns::Array{Array{Column,1},1}: The set of cycles and chains associated with variables\n\nOutput parameters\n\nfeas_val::Real:  The objective value of the feasible solution\ncolumns::Array{Array{Int,1},1}: The set of selected cycles and chains of the feasible solution\n\n\n\n\n\n","category":"method"},{"location":"functions/#KidneyExchange.initialize_column_pool","page":"Functions","title":"KidneyExchange.initialize_column_pool","text":"initialize_column_pool(instance, column_pool)\ninitialize_column_pool(\n    instance,\n    column_pool,\n    max_cycle_length\n)\ninitialize_column_pool(\n    instance,\n    column_pool,\n    max_cycle_length,\n    max_nb_cols\n)\n\n\nInitialize the pool of columns for the branch-and-price by enumerating all k-cycles up to an input maximum value of k.\n\nInput parameters\n\n*instance::Instance: The instance *column_pool::Vector{Column}: Pool of columns where initial columns will be pushed *max_cycle_length::Int: Maximum length of the cycles to be enumerated at initialization (0 if initialization is deactivated)\n\nmax_nb_cols::Int : Maximum number of columns added for each vertex, 0 if all columns are added\n\nOutput parameters\n\ncolumn_pool::Vector{Column} : set of columns initially added to the master problem\n\n\n\n\n\n","category":"function"},{"location":"functions/#KidneyExchange.initialize_master_IP","page":"Functions","title":"KidneyExchange.initialize_master_IP","text":"initialize_master_IP(instance, column_pool)\ninitialize_master_IP(instance, column_pool, bp_params)\ninitialize_master_IP(\n    instance,\n    column_pool,\n    bp_params,\n    time_limit\n)\n\n\nInitialization of the master problem with integer columns\n\nArguments\n\ninstance::Instance: The parsed instance that is to be solved, it contains the KEP graph and the bounds on the length of covering cycles and chains.\ncolumn_pool::Vector{Column}: the set of initial columns of the master\nbp_params::BP_params: parameters of the branch-and-price\ntime_limit::Float64: time limit for each solution of the master relaxation\n\nReturn values\n\nmaster::Model: the model of the restricted master problem\n\n\n\n\n\n","category":"function"},{"location":"functions/#KidneyExchange.isDonorSpouse-Tuple{KidneyExchange.PoolGenerator}","page":"Functions","title":"KidneyExchange.isDonorSpouse","text":"isDonorSpouse(pool_gen)\n\n\nDraws a random spousal relationship between donor and patient\nreturn true if willing donor is patient's spouse, false otherwise\n\n\n\n\n\n","category":"method"},{"location":"functions/#KidneyExchange.isPatientFemale-Tuple{KidneyExchange.PoolGenerator}","page":"Functions","title":"KidneyExchange.isPatientFemale","text":"isPatientFemale(pool_gen)\n\n\nDraws a random gender from the US waitlist distribution\nreturn true if patient is female, false otherwise\n\n\n\n\n\n","category":"method"},{"location":"functions/#KidneyExchange.isPositiveCrossmatch-Tuple{Float64}","page":"Functions","title":"KidneyExchange.isPositiveCrossmatch","text":"isPositiveCrossmatch(pr_PraIncompatibility)\n\n\nRandom roll to see if a patient and donor are crossmatch compatible\n\npr_PraIncompatibility: probability of a PRA-based incompatibility\nreturn true is simulated positive crossmatch, false otherwise\n\n\n\n\n\n","category":"method"},{"location":"functions/#KidneyExchange.node_master","page":"Functions","title":"KidneyExchange.node_master","text":"node_master(instance, column_pool)\nnode_master(instance, column_pool, bp_params)\nnode_master(instance, column_pool, bp_params, time_limit)\n\n\nInitialization of the restricted master problem\n\nArguments\n\ninstance::Instance: The parsed instance that is to be solved, it contains the KEP graph and the bounds on the length of covering cycles and chains.\ncolumn_pool::Vector{Column}: the set of initial columns of the master\nbp_params::BP_params: parameters of the branch-and-price\ntime_limit::Float64: time limit for each solution of the master relaxation\n\nReturn values\n\nmaster::Model: the model of the restricted master problem\n\n\n\n\n\n","category":"function"},{"location":"functions/#KidneyExchange.preprocess_graph_copies","page":"Functions","title":"KidneyExchange.preprocess_graph_copies","text":"preprocess_graph_copies(instance)\npreprocess_graph_copies(instance, reduce_arcs)\npreprocess_graph_copies(\n    instance,\n    reduce_arcs,\n    reduce_vertices\n)\npreprocess_graph_copies(\n    instance,\n    reduce_arcs,\n    reduce_vertices,\n    fvs\n)\n\n\nGet the data of each graph copy used in the subproblems of the column generation. The graph copies are charaterized by a source vertex and the set of vertices (optionally set of arcs) kept in the copy. Each altruist donor is the source of one graph copy. Preprocessing the vertices that can be reached with a given maximum number of arcs does not bring any improvement to the subproblem solution, so we do nothing at this stage.\n\nFor the other copies, either each donor/patient pair is the source of one copy, or we compute a feedback vertex set (FVS) that heuristically minimizes the cardinality of the set.  Each vertex of the FVS will then be the source of one copy in the column generation subproblems. In both cases, we then compute distances from and to the source in each subgraph. These will be used in the Bellman-Ford search at each solution of the subproblems.\n\nInput parameters\n\ninstance::Instance : The structure describing the characteristics of an instance including the compatibility graph\nreduce_arcs::Bool : A boolean parameter indicating whether or not arcs that are not useful in a copy should be eliminated from it (default value is false)\nreduce_vertices::Bool : A boolean parameter indicating whether or not vertices that are not useful in copy should be eliminated from it (default value is true)\nfvs::Bool : True if the copies correspond to an FVS, false if there is one copy per donor/patient pair\n\nOutput parameters\n\nsubgraphs::Graph_copies : The structure describing the preprocessed data of the graph copies\n\n\n\n\n\n","category":"function"},{"location":"functions/#KidneyExchange.print_and_check_solution","page":"Functions","title":"KidneyExchange.print_and_check_solution","text":"print_and_check_solution(cycles, chains, instance)\nprint_and_check_solution(cycles, chains, instance, verbose)\n\n\nFunction that prints the main characteristics of a solution and check that it satisfies all teh constraints\n\nInput parameters\n\ncycles::Vector{Vector{Int}}: list of cycles in the solution to display\nchains::Vector{Vector{Int}}: list of chains in the solution to display\ninstance::Instance: KEP instance whose solution it is\nverbose::Bool: true if the characteristics of the solution are printed, false if only the verification need be done\n\nOutput parameters\n\nNone\n\n\n\n\n\n","category":"function"},{"location":"functions/#KidneyExchange.process_node-Tuple{KidneyExchange.TreeNode, KidneyExchange.Instance, JuMP.Model, KidneyExchange.Graph_copies, KidneyExchange.BP_status, Vector{KidneyExchange.Column}, BP_params, JuMP.Model, TimerOutput, Float64}","page":"Functions","title":"KidneyExchange.process_node","text":"process_node(\n    tree_node,\n    instance,\n    mastermodel,\n    subgraphs,\n    bp_status,\n    column_pool,\n    bp_params,\n    master_IP,\n    timer,\n    time_limit\n)\n\n\nColumns generation of the node\n\nInput parameter\n\ntree_node::TreeNode: Branch-and-bound node to solve with column generation\n\nOutput parameter\n\ncolumn_flow::Dict{Pair{Int,Int}, Float64}: value of x_(i,j) of arc (i->j)`\n\n\n\n\n\n","category":"method"},{"location":"functions/#KidneyExchange.read_kep_file-Tuple{AbstractString, AbstractString}","page":"Functions","title":"KidneyExchange.read_kep_file","text":"read_kep_file(wmd_file, dat_file)\n\n\nContruct a KEP graph from a .wmd and a .dat input files. The format of these files can be found on the PrefLib website (see here for more details). The .dat file provides individual information on the patient and donor of each pair such as blood type. The .wmd file describes the edges of the KEP graph. For example, in the first instance of the benchmark, the .dat looks like this :\n\n\tPair,Patient,Donor,Wife-P?,%Pra,Out-Deg,Altruist\n\t1,A,B,0,0.05,2,0\n\t2,O,A,0,0.05,4,0\n\t3,A,B,0,0.05,2,0\n\t4,O,A,1,0.5875,3,0\n\t5,B,AB,0,0.05,0,0\n\t6,B,A,0,0.45,3,0\n\t7,O,A,0,0.45,4,0\n\t8,B,A,0,0.45,3,0\n\t9,O,A,0,0.45,4,0\n\t10,O,O,1,0.2875,11,0\n\t11,A,AB,0,0.05,0,0\n\t12,A,A,1,0.5875,3,0\n\t13,O,O,1,0.925,10,0\n\t14,O,A,0,0.45,4,0\n\t15,O,A,0,0.05,3,0\n\t16,O,B,1,0.2875,3,0\n\nAnd a preview of the .wmd file (including only a subset of the arcs) looks like this: \n\n\t# FILE NAME: 00036-00000001.wmd\n\t# TITLE: Kidney Matching - 16 with 0\n\t# DESCRIPTION:\n\t# DATA TYPE: wmd\n\t# MODIFICATION TYPE: synthetic\n\t# RELATES TO:\n\t# RELATED FILES: 00036-00000001.dat\n\t# PUBLICATION DATE: 2013-08-17\n\t# MODIFICATION DATE: 2022-09-16\n\t# NUMBER ALTERNATIVES: 16\n\t# NUMBER EDGES: 59\n\t# ALTERNATIVE NAME 1: Pair 1\n\t# ALTERNATIVE NAME 2: Pair 2\n\t# ALTERNATIVE NAME 3: Pair 3\n\t# ALTERNATIVE NAME 4: Pair 4\n\t...\n\t1, 5, 1.0\n\t1, 6, 1.0\n\t2, 1, 1.0\n\t2, 3, 1.0\n\t2, 11, 1.0\n\t2, 12, 1.0\n\t3, 5, 1.0\n\t3, 8, 1.0\n\t4, 1, 1.0\n\t4, 3, 1.0\n\t...\n\nParameters\n\nwmd_file::String : Absolute path of the .wmd file.\ndat_file::String : Absolute path of the .dat file.\n\n\n\n\n\n","category":"method"},{"location":"functions/#KidneyExchange.relaxed_arc","page":"Functions","title":"KidneyExchange.relaxed_arc","text":"relaxed_arc(instance, params)\nrelaxed_arc(instance, params, maxtime)\n\n\nDeterministic relaxed-arc formulation for a KEP problem. No cycle length limitation is imposed.\n\nParameters\n\ninstance::Instance: KEP instance to solve\nmaxtime::Real=60 : Maximum solving time in seconds\n\n\n\n\n\n","category":"function"},{"location":"functions/#KidneyExchange.set_time_limit-Tuple{JuMP.Model, Float64, String}","page":"Functions","title":"KidneyExchange.set_time_limit","text":"set_time_limit(model, time_limit, optimizer)\n\n\n\n\n\n\n","category":"method"},{"location":"functions/#KidneyExchange.solve_with_BP","page":"Functions","title":"KidneyExchange.solve_with_BP","text":"solve_with_BP(filename, K, L)\nsolve_with_BP(filename, K, L, bp_params)\nsolve_with_BP(filename, K, L, bp_params, timer)\nsolve_with_BP(filename, K, L, bp_params, timer, time_limit)\n\n\nThis is the main function to call for an execution of the branch-and-price algorithm on input file with given bounds on the length of covering cycles and chains and given options\n\nArguments\n\nfilename::String: path of the input data files, this should include the name of the files, but not the .dat and .wmd extensions\nK::Int: maximum length of cycles\nL::Int: maximum length of chains\nbp_params::BP_params: solution parameters of the branch-and-price\ntimer::TimerOutput: a timer that will provide detail of where the computational time was spent during the branch-and-price\ntime_limit::Float64: time limit of the algorithm, including parsing and prepreprocessing times\n\n#Output parametes\n\ninstance::Instance: The parsed instance that is to be solved, it contains the KEP graph and the bounds on the length of covering cycles and chains.\nsubgraphs::Graph_copies: Description of the graph copies of the extended edge formulation\nbp_status::BP_status:  Structure containing every relevant information on the execution of the algorithm (including the optimal solution)\n\n\n\n\n\n","category":"function"},{"location":"functions/#KidneyExchange.solve_with_mip","page":"Functions","title":"KidneyExchange.solve_with_mip","text":"solve_with_mip(filename, K, L)\nsolve_with_mip(filename, K, L, params)\nsolve_with_mip(filename, K, L, params, timer)\nsolve_with_mip(filename, K, L, params, timer, time_limit)\n\n\nThis is the main function to call to solve the input instance with given bounds on the length of covering cycles and chains and given options\n\nArguments\n\nfilename::String: path of the input data files, this should include the name of the files, but not the .dat and .wmd extensions\nK::Int: maximum length of cycles\nL::Int: Maximum length of chains\nparams::MIP_params: parameters of the MIP model and solver\ntimer::TimerOutput: a timer that will provide detail of where the computational time was spent during the branch-and-price\ntime_limit::Float64: time limit of the algorithm, including parsing and prepreprocessing times\n\nOutput parametes\n\ninstance::Instance: The parsed instance that is to be solved, it contains the KEP graph and the bounds on the length of covering cycles and chains.\nsubgraphs::Graph_copies: Description of the graph copies of the extended edge formulation\nbp_status::BP_status:  Structure containing every relevant information on the execution of the algorithm (including the optimal solution)\n\n\n\n\n\n","category":"function"},{"location":"functions/#KidneyExchange.traverse_preds-Tuple{Int64, Vector{Vector{Int64}}, Int64}","page":"Functions","title":"KidneyExchange.traverse_preds","text":"traverse_preds(v, pred, n)\n\n\nInner function for BellmanFordcycle_search to return path of exactly (n-1) of length ending at v from the table of predecessor\n\nArguments\n\nv::Int : The ending vertex\npred::Array{Array{Tuple{Int,Int},1},1}: table of predecessor containing tuples of predecessor and legnth of path to arrive the vertex\nn::Int: the length of the path\n\nReturn values\n\nc=Array{Int,1}: path of exactly (n-1) of length ending at v\n\n\n\n\n\n","category":"method"},{"location":"functions/#KidneyExchange.write_kep_file-Tuple{Graphs.SimpleGraphs.SimpleDiGraph, Matrix{Float64}, Vector{KidneyExchange.Blood_type}, Vector{KidneyExchange.Blood_type}, BitArray, Vector{Float64}, BitArray, String}","page":"Functions","title":"KidneyExchange.write_kep_file","text":"write_kep_file(\n    kep_graph,\n    edge_weight,\n    donorBT,\n    patientBT,\n    wifeP,\n    patientPRA,\n    is_altruist,\n    file_name\n)\n\n\nWrite a .wmd and a .dat files to store the input KEP graph in the same form as in Preflib. Store the files in ./data directory.\n\nParameters\n\nkep_graph::SimpleDiGraph: KEP graph to write\nedge_weight::Matrix{Float64}: weight of each eadge of the KEP graph\ndonorBT::Vector{Blood_type}: blood type of the donor of each pair\npatientBT::Vector{Blood_type}: blood type of the patient of each pair\nwifeP::BitArray: for each pair true iff the donor and patient are married\npatientPRA::Vector{Float64}: PRA of the patient of each pair\nis_altruist::BitArray: for each pair, true if the donor is an altruist donor\nfile_name::String: Name of the files (before the extensions)\n\n\n\n\n\n","category":"method"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"#KidneyExchange.jl","page":"Home","title":"KidneyExchange.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This a Julia package to solve the deterministic kidney exchange problem. It provides five different solution methods, two of which are based on a branch-and-price algorithm. The other three methods consist in solving compact integer programming formulations. These methods are described in Omer et al. (2022).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package also comes with three instance generators that allow to reproduce a benchmark similar to that used in the aforementionned report.","category":"page"},{"location":"#Input-data","page":"Home","title":"Input data","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package provides a parser (function read_kep_file) for the instances of the PrefLib library publicly shared by John P. Dickerson and described in Dickerson et al. (2012). Those instances must be downloaded from the PrefLib website and stored in the data/preflib folder before solving them with the algorithms of the package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Otherwise, three generators are provided with the package (functions generate_saidman_instance, generate_heterogeneous_instance and generate_sparse_unos_instance). One of them (generate_saidman_instance) will generate instances similar to those of the PrefLib library.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Users who wish to run our code on other existing instances may input them as .wmd file and read them with read_kep_file.","category":"page"},{"location":"#Integer-programming-solvers","page":"Home","title":"Integer programming solvers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package was fully tested with the two commercial MIP solvers CPLEX and Gurobi. Those can both be downloaded and used under an Academic licence at https://www.ibm.com/academic/home and https://www.gurobi.com.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you prefer running a fully open version of the package, it is possible to do so by using a chosen mixture of HiGHS, Clp, Cbc, and GLPK. Be aware that the execution of the algorithms may take longer than communicated in our article if you do so. In particular, for large instances, this is even true for the branch-and-price algorithms which rely on the capacity of the solver to solve the relaxed master problem with integer variables. The corresponding packages are documented at HiGHS.jl,  Cbc.jl, Clp.jl and Glpk.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To choose the solver, you need to set the field optimizer of the BP_params or MIP_params structure with one of the following options:","category":"page"},{"location":"","page":"Home","title":"Home","text":"HiGHS: use exclusively HiGHS, i.e., both for integer programs (IPs) and linear programs (LPs)\nGLPK: use exclusively GLPK\nClp: use Cbc for every integer program and solve the linear relaxations with Clp\nCbc: exactly the same as Clp (***default for MIP approaches***)\nGLPK-Cbc: use Cbc for every integer program and solve the linear relaxations with GLPK (***default for branch-and-price***)\nCPLEX: use exclusively CPLEX (requires a licensed installation of CPLEX)\nGurobi: use exclusively Gurobi (requires a licensed installation of Gurobi)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some parameters of the solvers (e.g. the number of threads used by the solver) can be set when calling the constructors of the parameters used by the desired algorithm. Additional details are given in the documentation of MIP_params and BP_params.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Packages Clp, Cbc, Gurobi and CPLEX are not included among the dependencies so they must be added and loaded (with using) if you wish to use one of them. This was necessary due to some compatibility issues with Clp and Cbc, and because CPLEX and Gurobi require a licensed installation.","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using KidneyExchange","category":"page"},{"location":"","page":"Home","title":"Home","text":"Generate an instance with 500 pairs of incompatible donors and receivers and 25 non-directed donors. The corresponding input files will be created in the \"data/sparse/\" folder of the package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"generate_sparse_unos_instance(500, 25, 1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Solve the instance with branch-and-price. The basic usage of this function requires as input, the instance (below \"sparse/sparse50025_1\"), and the parameters K and L (below 3 and 4, respectively).","category":"page"},{"location":"","page":"Home","title":"Home","text":"solve_with_BP(\"sparse/sparse_500_25_1\", 3, 4)","category":"page"},{"location":"","page":"Home","title":"Home","text":"As always with Julia, the first time the solve function is called, it takes extra time. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"In a more advanced use case additional parameters can be changed through the object BP_params. For instance, specify another branch-and-price formulation (the second true is to keep verbosity)","category":"page"},{"location":"","page":"Home","title":"Home","text":"solve_with_BP(\"sparse/sparse_500_25_1\", 3, 4, BP_params(true, true))","category":"page"},{"location":"","page":"Home","title":"Home","text":"Solve the instance using one of its compact MIP formulations (HPIEF by default). The basic usage of this function requires as input, the instance (below \"sparse/sparse50025_1\"), and the parameters K and L (below 3 and 4, respectively).","category":"page"},{"location":"","page":"Home","title":"Home","text":"solve_with_mip(\"sparse/sparse_500_25_1\", 3, 4)","category":"page"},{"location":"","page":"Home","title":"Home","text":"In a more advanced use case additional parameters can be changed through the object MIP_params. For instance, specify another MIP formulation (true is to keep verbosity)","category":"page"},{"location":"","page":"Home","title":"Home","text":"solve_with_mip(\"sparse/sparse_500_25_1\", 3, 4, MIP_params(KidneyExchange.EXTENDED_EDGE, true))","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"Modules = [KidneyExchange]\nOrder   = [:type]","category":"page"},{"location":"types/#KidneyExchange.BP_info","page":"Types","title":"KidneyExchange.BP_info","text":"mutable struct BP_info\n\nMutable structure where extra information about the branch-and-price execution is stored\n\nFields\n\nLB::Float64: best primal value\nUB::Float64: best dual value\nnb_col_root::Int: number of columns generated at root node\n\n\n\n\n\n","category":"type"},{"location":"types/#KidneyExchange.BP_params","page":"Types","title":"KidneyExchange.BP_params","text":"mutable struct BP_params\n\nMutable structure where the options of the branch-and-price solver are stored\n\nFields\n\noptimizer::String: LP and IP solver that will be used to solve the master (default is HiGHS)\nverbose::Bool: true if messages are printed during the solution (default = true)\nis_pief::Bool: true if the chains are considered in the master model using a position-indexed extended edge formulation (default = false)\nfvs::Bool: true if a feedback vertex set is used to reduce the number of graph copies (default = true)\nreduce_vertices::Bool: true if we try deleting useless vertices in graph copies (default = true)\nis_column_disjoint::Bool: true if we require column disjoint columns at each column generation iteration (default = true)\nmax_intersecting_columns::Int: true maximum number of generated columns covering each vertex (default = 6)\nis_tabu_list::Bool: true if we stop solving a subproblem as soon as it does not produce any positive cost column; this subproblem will be considered again when proving optimality (default = true)\nsolve_master_IP::Bool: true if we solve the master IP to find feasible solutions (default = true)\ntime_limit_master_IP::Float64: time limit (seconds) at each solution of the master IP (default = 10.0)\nfreq_solve_master_IP::Int: number of new columns that must be added in the master IP between two solutions of this IP (default = 1)\nrestart_for_IP::Bool: true if the root node can be solved twice to generate more columns when the IP master could not prove optimality of the relaxation value (default = true)\nnb_threads::Int: if the LP and IP solver can be called on multiple threads, specify the maximum number of threads that will be used.\n\n\n\n\n\n","category":"type"},{"location":"types/#KidneyExchange.BP_status","page":"Types","title":"KidneyExchange.BP_status","text":"mutable struct BP_status\n\nMutable structure where the results of the branch-and-price are stored\n\nFields\n\nbp_info::BP_info: extra info about the branch-and-price execution\nstatus::String: status of solution: ONGOING, OPTIMAL or TIMELIMIT\nobjective_value::Float64: objective value of the best solution found\nrelative_gap::Float64: final relative optimality gap\nbest_cycles::Vector{Vector{Int}}: selected cycles in the best primal value\nbest_chains::Vector{Vector{Int}}: selected chains in the best primal value\nnode_count::Int: total number of branch-and-bound nodes explored during the solution proces\nsolve_time::Float64: time spent in the solution process; this might be different from the specified time limit even if status is TIME_LIMIT, since parsing and preprocessing is counted in cpu time\nnb_cols_last_ip::Int: number of columns in the master IP at last solution\n\n\n\n\n\n","category":"type"},{"location":"types/#KidneyExchange.Graph_copies","page":"Types","title":"KidneyExchange.Graph_copies","text":"mutable struct Graph_copies\n\nMutable structure describing the copies of the graph: one copy per vertex or one copy per vertex of a feedback vertex set if the option is set. It is important to note that the copies related to altruist donors always appear first in the list of copies\n\nFields\n\nsources::Vector{Int}: source of each graph copy\nis_vertex_list::Vector{BitVector}: for each copy and each vertex, true if the vertex belongs to the copy\nd_to_vstar_list::Vector{Vector{Int}}: in each copy, distance from each vertex to the source\nd_from_vstar_list::Vector{Vector{Int}}: in each copy, distance from each vertex to the source\nnb_copies::Int: number of graph copies\nis_arc_list::Vector{BitVector}: for each copy and each arc index, true if the arc appears in the copy\nchain_mip::Model: shared MIP model that will be solved every time a chain subproblem needs to be solved to optimality\n\n\n\n\n\n","category":"type"},{"location":"types/#KidneyExchange.Graph_info","page":"Types","title":"KidneyExchange.Graph_info","text":"mutable struct Graph_info\n\n\n\n\n\n","category":"type"},{"location":"types/#KidneyExchange.Instance","page":"Types","title":"KidneyExchange.Instance","text":"struct Instance\n\nNon-mutable structure describing the instance that is solved\n\nFields\n\ngraph::SimpleDiGraph: graph describing compatibilities between pairs and  with altruist donors\nvertex_weight::Vector{Float64}: weight of each vertex\nedge_weight::Matrix{Float64}: weight of each arc (0 if there is no arc)\npairs::Vector{Int}: indices of the donor/patient pair vertices\naltruists::Vector{Int}: indices of the altruist donor vertices\nnb_pairs::Int: number of donor/patient pairs\nnb_altruists::Int: number of altruist donors\nmax_cycle_length::Int: maximum length of a feasible exchange cycle\nmax_chain_length::Int: maximum length of a feasible exchange chain\nis_vertex_weighted::Bool: true if all weights are actually on the vertices\n\n\n\n\n\n","category":"type"},{"location":"types/#KidneyExchange.MIP_params","page":"Types","title":"KidneyExchange.MIP_params","text":"mutable struct MIP_params\n\nMutable structure where the solving options of the compact formulation are stored\n\nFields\n\noptimizer::String: LP and IP solver that will be used to solve the master (default is HiGHS for IPs and LPs)\nverbose::Bool: true if messages are printed during the solution (default = true)\nmodel_type::Mip_model: type of MIP compact model that is to be solved (default = HPIEF)\nfvs::Bool: true if a feedback vertex set is used to reduce the number of graph copies (default = true)\nreduce_vertices::Bool: true if we try deleting useless arcs in graph copies (default = true)\nreduce_arcs::Bool: true if we try deleting useless arcs in graph copies (default = true)\nsymmetry_break::Bool: true if the MIP model is modified to reduce the number of optimal solutions (default = true)\nnb_threads::Int: if the LP and IP solver can be called on multiple threads, specify the maximum number of threads that will be used.\n\n\n\n\n\n","category":"type"},{"location":"types/#KidneyExchange.Mip_model","page":"Types","title":"KidneyExchange.Mip_model","text":"Mip_model\n\nEnumerated structure specifying the considered formulation when solving a compact formulation of the kidney exchange problem\n\nEnumerate values\n\nHPIEF: Hybrid position-indexed extended formulation\nEXTENDED_EDGE: Cycles are handled with an extended edge formulation and  chains are handled with position-indexed variables\nCYCLE_CUT: Cycles are handled with an extended edge formulation and  chains are handled with cycle cuts to avoid long cycles\nRELAXED_ARC: Arc formulation where the size of cycles and chains are not considered\n\n\n\n\n\n","category":"type"},{"location":"types/#KidneyExchange.PoolGenerator","page":"Types","title":"KidneyExchange.PoolGenerator","text":"mutable struct PoolGenerator\n\nCompatibility graph generator based on Saidman et al. (2006)\n\nThis is known colloquially as the \"Saidman Generator\".\n\n\n\n\n\n","category":"type"},{"location":"types/#KidneyExchange.Solution_status","page":"Types","title":"KidneyExchange.Solution_status","text":"mutable struct Solution_status\n\n\n\n\n\n","category":"type"},{"location":"types/#KidneyExchange.Subgraph_info","page":"Types","title":"KidneyExchange.Subgraph_info","text":"mutable struct Subgraph_info\n\n\n\n\n\n","category":"type"},{"location":"types/#KidneyExchange.VertexAltruist","page":"Types","title":"KidneyExchange.VertexAltruist","text":"struct VertexAltruist <: KidneyExchange.Vertex\n\n\n\n\n\n","category":"type"},{"location":"types/#KidneyExchange.VertexPair","page":"Types","title":"KidneyExchange.VertexPair","text":"struct VertexPair <: KidneyExchange.Vertex\n\n\n\n\n\n","category":"type"}]
}
